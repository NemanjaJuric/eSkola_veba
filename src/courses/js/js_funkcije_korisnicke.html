<h1><b>Korisničke funkcije</b></h1>
Korisničke funkcije su one koje sami definišemo.
<h2>Definisanje funkcije</h2>
Prilikom definisanja funkcije prvo stoji ključna reč <i>function</i>, zatim razmak, pa naziv funkcije, obične zagrade, pa vitičaste zagrade.
<br>
U okviru običnih zagrada mogu, ali i ne moraju, da stoje argumenti (dodatne informacije koje koristi funkcija).
<br>
U okviru vitičastih zagrada se nalazi telo funkcije, odnosno, naredbe koje funkcija izvršava.
<br>
Takođe, u zavisnosti od toga da li funkcije u telu sadrze naredbu <i>return</i> razlikujemo ih kao povratne (one koje vracaju neku vrednost) ili nepovratne (one koje ne vracaju nijednu vrednost, samo izvršavaju nešto bez povratne informacije).
<br>
<br>
<xmp class = "primer_ta" >
function naziv_funkcije(niz argumenata){
	telo funkcije(niz naredbi)
}
</xmp>
<br>
<h2>Osobine</h2>
Ključna reč <i>function</i> obavezna.
<br>
<br>
Naziv funkcije je takođe obavezan deo funkcije, kako bismo kasnije mogli da je pozivamo. 
Naziv može biti bilo koji niz karaktera, osim rezervisanih reči.
Naziv je često kratak opis onoga što funkcija izvršava. Na primer, funkcija koja računa kvadratni koren nekog broja imaće naziv "kvadratniKoren", "kvKoren" ili "koren".
<br> 
<br>
U okviru običnih zagrada mogu, ali i ne moraju, da stoje ulazni argumenti (dodatne informacije koje koristi funkcija).
Ulazni argumenti funkcije nisu obavezni. Funkciji se prilikom poziva prosleđuju ovi argumenti, koje ona koristi u radu. Ukoliko se funkciji prilikom
poziva ne proslede svi ulazni argumenti, oni koji nisu proslni dobijaju vrednost <i>undefined</i>. 
<br>
U ovom jeziku moguće je da prilikom definisanja funkcije ne navedemo argumente, a da ih prilikom poziva funkcije unesemo.
<br>
<br> 
U okviru vitičastih zagrada se nalazi telo funkcije, odnosno, naredbe koje funkcija izvršava. 
<br>
U telu funkcije su naredbe koje funkcija izvršava. I telo može biti izostavljeno, ali onda funkcija ne bi imala smisla, pa se podrazumeva da je ovo obavezan deo. 
<br>U telu funkcije mogu se definisati nove promenljive, ali i pozivati postojeće funkcije ukoliko se ukaže takva potreba. Promenljive koje se definišu u telu funkcije "žive" samo u toku rada funkcije. Kada funkcija završi sa radom njima nije moguće pristupiti.

<br>
<h2>Primeri povratnih funkcija</h2>
<xmp class = "primer_ta" >
function bezArgPovratna(){
	return 5;
}
</xmp>
<br>
Funkcija <i>funkcijaBezArgPovratna()</i> nema ulaznih argumenata, ali ima povratnu
vrednost. Svaki put kada se pozove ova funkcija ona će vratiti broj 5.
<br>
<br>
<xmp class = "primer_ta" >
function duplirajBroj(x){
	return 2*x;
}
</xmp>
<br>
Funkcija <i>duplirajBroj(x)</i> očekuje da joj se prilikom poziva obezbedi jedan ulazni argument, broj x, a potom ona vrati duplu vrednost tog broja. Ukoliko se ne prosledi ulazni argument, ova funkcija vratiće vrednost "NaN"(not a number - nije unet broj).<br>
<br>
Funkcija <i>zbirBrojeva(a,b,c)</i> ima tri ulazna argumenta, a potom računa zbir unetih brojeva.
<br>
<xmp class = "primer_ta" >
function zbirBrojeva(a,b,c){
	return a+b+c;
}
</xmp>
<br>
Ukoliko neki od argumenta pri pozivu funkcije <i>zbirBrojeva(a,b,c)</i> nije unet povratna vrednost funkcije će biti "NaN".
<br>

<br>
U okviru funkcije možemo i definisati nove promenljive, kada nam zatrebaju.
Ukoliko promenljive definisemo sa ključnom reči <i>var</i> ispred, one će biti vidljive samo u okviru funkcije, a ukoliko ih definišemo bez ključne reči,
moći ćemo da ih koristimo i nakon završetka rada funkcije.
<br>
<xmp class = "primer_ta">
function zbirBrojeva1(a,b){
	var zbir=a+b;
	return zbir;
}
</xmp>
<br>
Funkcija <i>zbirBrojeva1(a,b)</i> ima dva ulazna argumenta, a u telu funkcije je definisana nova promenljiva "zbir", koja računa zbir ulaznih argumenata. <br>Potom, funkcija vraća vrednost koja je sačuvana u promenljivoj <i>zbir</i>.
<br>
<br>
Program kada naiđe na naredbu <i>return</i> odmah izlazi iz funkcije, t.j. ukoliko u funkciji stoji neka naredba nakon naredbe <i>return</i>,
 ona nikada neće biti izvršena, što možemo videti u sledećem primeru:
<br>
<xmp class = "primer_ta" >
function zbirBrojeva2(a,b){
	var zbir=a+b;
	return zbir;
	alert("Ovo se nikada nece izvrsiti");
}
</xmp>
<br>
<h2>Primeri nepovratnih funkcija</h2>
<br>
<xmp class = "primer_ta" >
function bezArgNepovratna(){
	document.write("Funkcija bez argumenata i povratne vrednosti");
}
</xmp>
<br>
Funkcija <i>funkcijaBezArgNepovratna()</i> nema ulaznih argumenata, ni povratnu vrednost, a pri pozivu na internet stranici se ispisuje tekst <i>Funkcija bez argumenata i povratne vrednosti.</i>
<br>
<br>
<xmp class = "primer_ta" >
function kvadratBroja(x){
	document.write(x*x);
}
</xmp>
<br>
Funkcija <i>kvadratBroja(x)</i> ima jedan ulazni argument, broj <i>x</i>, a potom ispisuje kvadrat tog broja.
<br>
<h2>Pozivanje funkcije</h2>
Funkcija se poziva navođenjem njenog imena i prosleđivanjem neophodnih argumenata.
<xmp class="primer_ta" >
Primer 1:
&lt;html&gt;
  &lt;head&gt;
    &lt;script&gt;
    function kvadratBroja(x){
	    return x*x;
    }
    &lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Kvadrat broja&lt;/h1&gt;
    &lt;script&gt;
    document.write(kvadratBroja(5));
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</xmp>
<button class = "button_copy">Vidi primer</button>
<br>
<br>
<xmp class="primer_ta" >
Primer 2:
&lt;html&gt;
  &lt;head&gt;
    &lt;script&gt;
    function kvadratBroja(x){
	    return x*x;
    }
    function povrsinaKvadrata(x){
	    var povrsina=kvadratBroja(x)
	    return povrsina;
    }
    &lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Površina kvadrata&lt;/h1&gt;
    &lt;script&gt;
    document.write(povrsinaKvadrata(5));
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</xmp>
<button class = "button_copy">Vidi primer</button>
<br>
<h2>Callback funkcije</h2>
Callback je mehanizam, poznat i u drugim jezicima, koji omogućava da se funkcija prosledi kao parametar.
<br>
<br> 
Ukoliko se programira složenija aplikacija na vebu, često se dolazi u poziciju da je neophodno sačekati neke podatke sa servera u toku izvršavanja samog programa. 
Rad programa se tada zaustavlja i nastavlja se tek kada svi podaci pristignu. 
U momentu kada server odgovori, poziva se callback funkcija koja služi kao početna tačka za nastavak rada.
<br>
<br> 
Primer callback funkcije je zadavanje tajmera koji poziva callback funkciju posle određenog zadatog vremena.
<br>
<xmp class="primer_ta" >
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Callback funkcija&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;script&gt;
    function fun(){
      document.body.style.backgroundColor = "#003";
    }
    window.setTimeout(fun, 4000);
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</xmp>
<button class = "button_copy">Vidi primer</button>
<br>
U prethodnom primeru definisana je callback funkcija <i>callbackFunkcija()</i> i postavljen je tajmer koji je poziva nakon četiri sekunde. 
Ovaj primer pauzira izvršavanje programa na četiri sekunde. Konkretno, funkcija <i>callbackFunkcija()</i> menja boju pozadine u tamno plavu.
<br>
Specifično je i navođenje callback funkcije u metodi <i>setTimeout()</i>. Navodi se samo naziv funkcije bez zagrada.
<br>
<br> 
Callback funkcije se često koriste kao funkcije za obradu događaja (event hendler), odnosno aktiviraju se kao posledica neke aktivnosti korisnika.
<br>
<xmp class="primer_ta" >
var niz = [14, 5, 6, -2, 7];
if (niz.every(veci)){
  console.log("Svi elementi su veći od nule.");
}
function veci(a){
  return a > 0;
}
</xmp>
<br>
U ovom primeru funkcija <i>veci()</i> je u ulozi callback funkcije i zadata je kao parametar metodi <i>every()</i>.
Ovaj program će u konzolu upisati tekst: <b>Svi elementi su veći od nule.</b>
<br>
<h2>Zatvorenja funkcije</h2>
Program kada izađe iz funkcije sve lokalne promenljive prestaju da postoje i njima nije moguće pristupiti. 
Logičan zaključak je da se ne može pristupiti unutrašnjoj funkciji ukoliko program izađe iz nadfunkcije. 
Međutim, u programskom jeziku <i>JavaScript</i> ovo nije slučaj. Moguće je pristupiti unutrašnoj funkciji i kada se završi sa radom sa nadfunkcijom. 
Ovakva unutrašnja funkcija sme da koristi promenljive svoje nadfunkcije i zovemo je zatvorenje.
<br>
<br>
Dakle, zatvorenje je unutrašnja funkcija koja se poziva van svoje nadfunkcije, ali i dalje ima pristup lokalnim promenljivama nadfunkcije.
<br>
Najčešća upotreba zatvorenja funkcija je kada se upotrebljava callback mehanizam i kada se kreiraju funkcije koje obrađuju događaje.
<br>
<xmp class="primer_ta" >
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Zatvorenje funkcija&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;script&gt;
    function nadfunkcija(){
    	var broj = 0;
    	function unutrasnjafunkcija(){
    		broj++;                    
    		document.write("BROJ: " + broj+"<br>");  
    	}
	    window.setTimeout(unutrasnjafunkcija, 5000);            
	    unutrasnjafunkcija();                                   
	    document.write("Nadfunkcija je završena!"); 
    }
    nadfunkcija();
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</xmp>
<button class = "button_copy">Vidi primer</button>
<br>
U prethodnom primeru definisana je funkcija <i>nadfunkcija()</i>. U njoj je prvo definisana lokalna promenljiva <i>broj</i>, a zatim i unutrašnja funkcija <i>unutrasnjafunkcija()</i>, koja povećava promenljivu broj i ispisuje je. 
Sledeća u nizu naredba je <i>setTimeout(unutrasnjafunkcija, 5000)</i>, ali ona će se izvršiti tek za pet sekundi, odnosno prvo će se izvršiti naredbe ispod koje stoje ispod nje. 
Poziva se funkcija <i>unutrasnjafunkcija()</i> koja u konzoli ispisuje broj <b>1</b>, a zatim se izvršava sledeća naredba, t.j. u konzoli se ispisuje tekst: <b>Nadfunkcija je zavr\v sena!</b>. 
<br>
<br>
Tek sad se izvršava funkcija <i>unutrasnjafunkcija()</i> koja je pozvana callback mehanizmom. Na ovaj način će se unutrašnja funkcija, nakon završetka rada nadfunkcije, još jednom izvršiti. 
Promenljivoj <i>broj</i> se ponovo pristupa iako je program izašao iz nadfunkcije, a u konzoli će se upisati broj <b>2</b>. 
Dakle, preko funkcije <i>unutrasnjafunkcija()</i> ostalo je "živo" celo njeno okruženje, odnosno sve lokalne promenljive iz funkcije <i>nadfunkcija()</i>. 
Isto bi se dogodilo čak i da postoji više nivoa ugnježdenih funkcija.
<br>
<h2>Objekat <span class = "primer_text">this</span></h2>
Na objekat <span class = "primer_text">this</span> se najčešće nailazi kada se kreiraju funkcije događaja. U tom slučaju <span class = "primer_text">this</span> predstavlja element na koji je kliknuto. 
<br>
<br>
Objekat <span class = "primer_text">this</span> predstavlja kontekst u kome se izvršava funkcija.
<br>
<br>
 U programskom jeziku JavaScript objekat <span class = "primer_text">this</span> se formira tokom izvršavanja funkcije. 
 Svaka funkcija ima svoj <span class = "primer_text">this</span> objekat. Kako se JavaScript funkcija može pozivati na pet različitih načina, tako i <span class = "primer_text">this</span> može biti pet različitih objekata. 
 Na programerima je da kontrolišu kako će funkcija biti pozvana i da predvide šta će <span class = "primer_text">this</span> predstavljati u funkciji.
<br>
<xmp class="primer_ta" >
function fun() {}
fun();
</xmp>
<br>
Svaka funkcija koju pozivamo na način dat prethodnim primerom u suštini nema <span class = "primer_text">this</span>. 
Preciznije, u ovako pozvanoj funkciji, objekat <span class = "primer_text">this</span> postoji i on je <span class = "primer_text">window</span>.
<br>
<xmp class="primer_ta" >
obj.metod = function funkcija() {}
obj.metod();
</xmp>
<br>
Kada je funkcija pozvana na ovaj način <span class = "primer_text">this</span> je tada objekat iz koga je funkcija pozvana. 
Odnosno, u funkciji se kreira lokalna promenljiva <span class = "primer_text">this</span> koja predstavlja referencu na objekat čiji je ta funkcija metod.
Ako je jedna ista funkcija metod različitih objekata, <span class = "primer_text">this</span> će se razlikovati zavisno od toga iz kog objekta je pozvana funkcija.
<br>
<xmp class="primer_ta" >
function Klasa() {}
var obj = new Klasa();
</xmp>
<br>
U prethodnom primeru operator <i>new</i> kreira novi objekat i izvršava konstruktorsku funkciju u kontekstu tog objekta (kao da je pozvana iz njega). 
Objekat <span class = "primer_text">this</span> u funkciji konstruktora će referencirati na taj novi objekat.
<br>
<xmp class="primer_ta" >
function fun(p1, p2, p3...) {}
fun.call(obj, v1,v2,v3...)
</xmp>
<br>
Ovaj primer prikazuje način pozivanja funkcije metodom <i>call()</i>. Metod <i>call()</i> uvek ima jedan parametar više od same funkcije. 
To je zato što prvi parametar predstavlja objekat koji se prosleđuje funkciji kao <span class = "primer_text">this</span>.
<br>
<br>
Metod <i>apply()</i> radi isto kao i metod <i>call()</i>, ali malo drugačijim stilom. Ima samo dva parametra. 
Prvi parametar je objekat koji će u funkciji predstavljati <span class = "primer_text">this</span>, a drugi parametar je niz koji sadrži vrednosti za parametre funkcije.
Poziv funkcije metodom <i>apply()</i> prikazan je na sledećem primeru.
<br>
<xmp class="primer_ta" >
function fun(p1, p2, p3...) {}
fun.apply(obj, [v1,v2,v3...]);
</xmp>
<br>
Na sledećem primeru prikazana je upotreba <span class = "primer_text">this</span> objekta.
<br>
<xmp class="primer_ta" >
function fun(){
    console.log(this.id ? this.id : "Nepoznat ID");
}
var prvi = {id:"PRVI"};
var drugi = {id:"DRUGI"};
prvi.metod = fun;
drugi.poziv = fun;
prvi.metod();    
drugi.poziv();   
fun();          
document.getElementById("blok").onclick = fun;
</xmp>
<br>
Prvo je definisana funkcija <i>fun()</i>. Ona ima objekat <span class = "primer_text">this</span>, ali mora se proveriti da li taj objekat ima svojstvo <i>id</i>. 
Ako ima, ispisaće se samo svojstvo <i>id</i>, ako ne, dobićemo poruku o tome.
<br>
<br>
Zatim kreirana su dva objekta: <i>prvi</i> i <i>drugi</i> i pri tom im je već definisano <i>id</i> svojstvo kao string u kome se nalazi njihov naziv. 
Zatim se tim objektima dodaju još po jedan metod koji predstavlja referencu na funkciju <i>fun</i>. Pozivom metoda tih objekata dobijaju se različite vrednosti. 
<br>
<br>
Naredba <i>prvi.metod();</i> vratiće string <b>PRVI</b>, dok će naredba <i>drugi.poziv();</i> vratiti string <b>DRUGI</b>. 
Nakon toga se na standardan način poziva funkcija <i>fun()</i>, a tada je objekat <span class = "primer_text">this</span> referenca na <span class = "primer_text">window</span>, koji ne poseduje svojstvo <i>id</i>. 
<br>
<br>
Na kraju, pretpostavljeno je da u HTML dokumentu postoji neki element, npr. <span class = "primer_text">&lt;div id="blok"&gt;...&lt;/div&gt;</span>. 
Tom elementu dodata je funkcija događaja, koja kada korisnik klikne na njega, poziva funkciju <i>fun()</i>. 
Rezultat koji se u ovom slučaju dobija je <b>blok</b>, jer objekat <span class = "primer_text">this</span> će biti referenca na element na koji je kliknuto.
<br>
<br>
<div class="zadatak">
<b>Zadatak: </b>Napiši (povratnu) funkciju koja računa površinu pravougaonika.</div>