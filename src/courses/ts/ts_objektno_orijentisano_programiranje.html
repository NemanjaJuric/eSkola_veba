<h1>Objektno orijentisano programiranje</h1>
Objektno orijentisano programiranje je programska paradigma zasnovana na konceptu "objekta", koji može da sadrži podatke u vidu polja i kôd u vidu procedure koja se još naziva metod. Osim ovog koncepta objektno orijentisano programiranje  odlikuju i 
koncepti kao što su klase, nasleđivanje, enkapsulacija, apstraktne klase, polimorfizam itd. Zbog toga objektno orijentisano programiranje ima bitnu ulogu u programskom jeziku TypeScript.
<h3>Objekti</h3>
 Svaki entitet koji ima stanje i ispoljava ponašanje naziva se objekata. Objekat u programskom jeziku TypeScript predstavlja samostalan entitet koji se sastoji od podataka i procedura <!--postupak--> koje manipulišu<!--rukuju--> podacima.
 Polja u objektu opisuju karakteristike<!--osobine--> objekta dok metode opisuju njegovo ponašanje. Ako uzmemo npr. psa kao primer objekta on ima svoje karakteristike kao što su ime, visina, rasa, težina i ponašanja kao što je lajati, trčati, pružiti šapu itd. 
Objekat može da sadrži razne vrste podataka počevši od prostih tipova(kao što su brojevi ili niske karaktera), strukture (kao što su nizovi) pa sve drugih objekata. U programskom jeziku TypeScript objekat se može kreirati <!--definisatina-->na dva načina:  
<ul style="list-style-type:circle">
  <li>Eksplicitno pomoću <span class = "primer_text"> {} </span></li>
  <li>Konstruktora klase</li>
</ul> 
U ovom odeljku opisan je prvi način kreiranja objekta. Sintaksa za eksplicitno kreiranje objekta je:
<xmp class = "primer_ta">  
let ime_objekta = {
                ime_polja_1: vrednost_polja_1,
                ime_polja_2: vrednost_polja_2,
                          ...
                ime_polja_n: vrednost_polja_n,

                ime_metoda_1: function (parametri):tip_pov_vred
                                        { 
              
                                        },
                ime_metoda_2: function (parametri):tip_pov_vred
                                        { 
                         
                                        } 
                };
 
 </xmp>
 Promenljiva <span class = "primer_text">ime_objekta</span> pokazuje <!--čuva adresu objekta?-->  na objekat koji je kreiran. Tip promenljive eksplicitno kreiranog objekta je uvek <b>Object</b> zbog toga se nikad ne deklariše tip promenljive.
 Sadržaj objekta se navodi unutar <span class = "primer_text"> {}</span>.  Uvek se prvo navodi ime za kojim zatim sledi znak <span class = "primer_text">:</span> posle kojeg se navodi vrednost polja ili deklaracija i definicija funkcije. (u zavisnosti od toga šta se definiše)
 Na kraju svake definicije <!--opisa--> polja ili funkcije ide znak <span class = "primer_text">,</span> posle kojeg počinje nova definicije.
 <xmp class = "primer_ta">  
let pas = {

    ime: 'Lesi',
    godine: 5,
    visina: 70,
    težina: 50,
    vakcinisan: true,
    omiljeni_drugari: ['Žućo', 'Švrća', 'Bleki'],

    laje: function ():string
            { 
             return 'Av avaav! Ja sam dobar pas.';    
            },
			
    brzina_kretanja: function (put: number, vreme: number): number
            { 
              return  put/ vreme;
            },
			
    svi_drugari: function (): string
            { 
        let s: string = pas.ime + ' omiljeni drugari za igru su: ';
        
        for (let i = 0; i < pas.omiljeni_drugari.length;i++)
            { 
            s = s + pas.omiljeni_drugari[i] + ' , ';
            }  
        return s.substring(0,s.length-2)+ '.'; 
            }        
            
}


alert(pas.laje());
alert(pas.brzina_kretanja(5, 0.5));
alert(pas.svi_drugari());

alert(pas instanceof Object); // Pomoću operatora instaceof može da se proveri da li određeni objekat pripada određenoj klasi
 </xmp>
Znak <span class = "primer_text">.</span> se koristi da bi se pristupilo vrednostima polja i pozivima metoda objekata.<br><br> Da bi se pristupilo vrednosti polja sintaksa je:  <span class= "primer_text">ime_objekta.ime_polja</span>.<br><br> Da bi se pristupilo pozivu metoda sintaksa je:<span class= "primer_text">ime_objekta.ime_metoda(lista_argumenata)</span>.
<div class = "napomena">Na isti način se pristupa vrednostima polja i pozivima metoda objekata koji su kreirani pomoću konstruktora klase. Jedina razlika je što u definiciji klase se koristi sintaksa <span class = "primer_text">this.ime_polja</span> ili <span class = "primer_text">this.ime_metoda(lista_argumenata)</span>. Upotrebom ključna reč <b>this</b> je način da se u klasi opiše sintaksa  
<span class = "primer_text">ime_objekta.ime_polja</span> ili <span class = "primer_text">ime_objekta.ime_metoda(lista_argumenata)</span> koja ća važiti za sve objekte te klase.</div>
Objekte je moguće koristiti kao parametre funkcije.
 <xmp class = "primer_ta">  
function moja_funkcija(o_1: { ime: string, prezime: string }, o_2:{godine:number, tezina:number}):string
{ 

return 'Ova osobe se zove ' + o_1.ime + ' ' +o_1.prezime + '. Ima '+o_2.godine+' godina ' + ' i teška je '+o_2.tezina + ' kilograma.'
}

alert (moja_funkcija({ ime: 'Dušan', prezime: 'Dušanović' }, { godine: 26, tezina: 92 }));
 </xmp>
 Argumenti funkcije se prosleđuju kao <span class = "primer_text">{}</span> u kojima se mora isto navest imena parametara sa željenim vrednostima.
<h2>Klase</h2>
Programski jezik TypeScript podržava koncept klase koja predstavlja jednu od osnovnih odlika objektno orijentisanog programiranja. Klasa predstavlja definiciju objekta, koje podatke može da sadrži i koje akcije može da obavlja. Ona služi kao matrica<!--plan--> po kojoj se objekti kreiraju. Objekat pripada određenoj klasi ako poseduje svojstva<!--osobine--> koje su opisane u toj klasi kao što su polja<!--atributi-->, metodi itd.
<br><br>
Za deklaraciju klase potrebno je koristiti ključnu reč <b>class</b>. Sintaksa je:
 <xmp class = "primer_ta">  
class ime_klasa 
{

//kôd kojim se opisuju svojstva klase

}
 </xmp>
 Posle ključne reči <b>class</b> sledi ime klase za koje važi pravila davanja imena kao kod promenljivh. Nakon imena klase sledi definicija klase koja opisuje sva svojstva klase. Definicija klase može sadržati:<br>
 <ul style="list-style-type:circle">
  <li><b>Polja -</b> Polje je bilo koja promenljiva deklarisana u klasi. Polja predstavljaju podatke koji se odnose na objekte i na taj način ih opisuju.</li>
  <li><b>Konstruktor -</b> Konstruktor je specijalna funkcija koja se poziva prilikom  kreiranja objekta. </li>
  <li><b>Metod -</b> Metod je funkcija koja predstavlja akciju koju objekat može da preduzme. </li>
</ul> 
<br>
Polja,konstruktori i metodi se još nazivaju svojstvima klase.<!--Stvarno nemam pojma kako da prevedem data members a da ne zvuči glupo.--> Konstruktor omogućava da se tokom kreiranja objekta postave početne vrednosti  polja u objektu. Zbog toga prilikom deklarisanja i definisanja konstruktora u klasi treba odrediti polja koja će biti parametri u konstruktoru.
 <xmp class = "primer_ta">  
class Osoba 
  {
    ime: string;
    prezime: string;
    visina:number;
    težina:number;
    verska_pripadnost:string;
   
    constructor(ime:string, prezime:string, visina:number)
	  {
	    this.ime     = ime;
        this.prezime = prezime;
        this.visina  = visina;   
      } 

    metod_klase():string
         {
          let s: string;
          return  s = this.ime + ' ' + this.prezime;
         }
  }
  
  
 let Srbin = new Osoba('Stefan', 'Nemanja', 190);
 alert(Srbin.metod_klase());
 </xmp>
 U ovom primeru definisana je klasa koja ime <b>Osoba</b>. Ona sadrži polja <b>ime</b>, <b>prezime</b>, <b>visina</b>, <b>verska_pripadnost</b> i metod <b>metod_klase</b>.
 <br><br>
 <ul style="list-style-type:circle">
  <li>Klasne deklaracije funkcija ne sadrži ključnu reč <b>function</b></li>
  <li>Ime konstruktora svake klase je <b>constructor</b> </li>
  <li>Može postojati više deklaracija konstruktora ali samo jedna implemnetacija. (function overloading)</li>
  <li>Ključna reč <b>this</b> omogućava korišćenje polja i metoda unutar klase. Takodje <b>this</b> se koristi kako bi se izbegla dvosmislenost kada je ime polja i parametara metoda isto.</li>
</ul> 
<div class = "napomena">U zavisnosti od konteksta reč <b>constructor</b> može biti ključna reč zbog toga se preporučuje da se koristi samo pri imenovanju konstruktora klase. Ako se ne definiše konstruktor onda kompajler toj klasi dodeljuje generički konstruktor</div>

Sintaksa za korišćenje polja unutar klase:<span class = "primer_text">this.ime_polja</span>
<br><br>
<b>KREIRANJE OBJEKTA KLASE</b>
<br><br>
Da bi se kreirao objekat klase potrebno je upotrebiti ključnu reč <b>new</b> iza koje sledi ime klase. Objekti klase se još nazivaju instance.<br><br> Sintaksa je: <span class = "primer_text"> let ime_objekta = new ime_klase (lista_argumenata)</span>
<xmp class = "primer_ta">  
class Pas
  { 

    ime : string;
    rasa: string;
    godine: number;
    težina: number;

    constructor(ime:string, rasa:string)
    { 
        this.ime  = ime;
        this.rasa = rasa;
    }

    lavež()
    {  
        alert('Vuvu!');
    }
  }

let seoski_pas = new Pas('Žućo', 'mešanac');

seoski_pas.lavež();
 </xmp>
 U ovom primeru je napravljen objekat <span class = "primer_text">seoski_pas</span> koji pripada klasi <span class = "primer_text">Pas</span>. Prilikom poziva konstruktora prosleđene su vrednosti  'Žućo' i 'mešanac'.
 <br><br>
 <b>Tip Objekta je klasa iz koje je izveden.</b>
 <div class = "napomena"> Pomoću operatora <b>inasanceof</b> može da se proveri da li objekat pripada određenoj klasi.</div>
 <xmp class = "primer_ta">  
class Nindž_klasa
    {
    polje: string = 'U suštini za ovaj primer klasa može da bude prazna.';
    }

class Još_opasnija_Nindž_klasa extends Nindž_klasa
    {
    polje_1: string = ' Najopasniji nindža je Hattori Hanzo.';
    }

class Obična_klasa
{ 


}

let j = new Još_opasnija_Nindž_klasa();

alert(j instanceof Obična_klasa);
alert(j instanceof Još_opasnija_Nindž_klasa);
alert(j instanceof Nindž_klasa);
 </xmp>
 Operator <b>instanceof</b> vraća vrednost true i za nadklasu!
 <h3>Nasleđivanje klase</h3>
 Nasleđivanje <!--klase--> je mehanizam <!--koncept--> koji omogućava da se od postojeće klase dobije nova klasa koja sem konstruktora poseduje sve osobine kao postojeća klasa. Objekti nove klase poseduju ista polja i funckije kao objekti postojeće klase.
 Klasa od koje se dobija nova klase naziva se nadklasa, roditeljska ili super klasa. Klasa koja nastaje od roditeljske klase naziva se podklasa ili dečija<!--ptomak--> klasa. Da bi jedna klasa nasledila drugu klasu potrebno je koristi ključnu reč <b>extends</b>. <br><br>Sintaksa je:
 <xmp class = "primer_ta">  
   class ime_podklasa extends ime_nadklase 
   {
   
   }
 </xmp>
 <div class = "napomena">Klasa može imati samo jednu nadklasu i neograničen broj podklasa. </div>
<xmp class = "primer_ta">  
class Osoba
{ 
    ime: string;
    private prezime: string;
    godine: number;

    constructor(ime:string, godine:number)
    { 
        this.ime = ime;
        this.godine = godine;

    }
    
    pozdrav():void
    { 
        alert( 'Pozdrav moje ime je ' + this.ime + ' i imam '+ this.godine + ' godina.');
    }

}

class Nastavnik extends Osoba
{ 
    nastavni_predmet: string;
    razdredni_starešina: boolean;
    ime_škole: string;

    constructor(nastavni_predmet: string, razdredni_starešina: boolean, ime:string, godine:number)
         { 
           super(ime,godine);
           this.nastavni_predmet = nastavni_predmet;
           this.razdredni_starešina = razdredni_starešina;
         }

    prosek_ocena_u_odeljenu(...ocene:number[]):number
    { 
        let p: number = 0;

        for (let i = 0; i < ocene.length; i++)
        {
            p = p + ocene[i];
        }

        return p/ocene.length;
    }

}

let profesor_mateamtike = new Nastavnik('Matematika', false, 'Dušan', 24);


profesor_mateamtike.pozdrav();
alert(profesor_mateamtike.prosek_ocena_u_odeljenu(5, 4, 1, 1, 2, 4, 3, 3, 5));
 </xmp>
 U ovom primeru klasa <b>Nastavnik</b> nasleđuje klasu <b>Osoba</b>. Svaki nastavnik je osoba ali svaka osoba nije nastavnik. Pošto klasa <b>Nastavnik</b> nasleđuje klasu <b>Osoba</b> nema potrebe da se u klasi <b>Nastavnik</b> ponovo definišu polja <b>ime</b>, <b>prezime</b>, <b>godine</b> i metod <b>pozdrav</b>.
 <br><br>
Za poziv metoda nadklase u metodu podklase koristi se ključna reč <b>super</b>. <br>Sintaksa je: <span class = "primer_text"> super.ime_metoda_nadklase </span>
<div class = "napomena">Svaki konstruktor podklase mora sadržati poziv konstruktora nadklase. Za poziv konstruktora nadklase koristi se  <b>super(lista_argumenata)</b>. Tip povratne vrednosti konstruktora je void. <br>Ne postoji izraz <span class = "primer_text">super.ime_polja</span> već samo <span class = "primer_text">this.ime_polja</span> !</div>
<xmp class = "primer_ta"> 
  //Umesto
  constructor(nastavni_predmet: string, razdredni_starešina: boolean, ime:string, godine:number)
         { 

           this.ime = ime;           //Ovo je implementacija
		   this.godine = godine;     //konstruktora nadklase

		   
           this.nastavni_predmet = nastavni_predmet;
           this.razdredni_starešina = razdredni_starešina;
         }
  // Piše se
 constructor(nastavni_predmet: string, razdredni_starešina: boolean, ime:string, godine:number)
         { 
		 
           super(ime,godine);      //Konstruktor nadklase
		   
		   
           this.nastavni_predmet = nastavni_predmet;
           this.razdredni_starešina = razdredni_starešina;
         }
</xmp>
Ovo nije ispravan kod , već služi samo kao poređenje kako bi se razjasnila uloga konstruktora nadklase u konstruktoru podklase.
<br><br>
<b>PREVLADAVANJE<!--prevazilaženje u knjizi pise--><!--redefinicija--> <!--zamena imeplementacije metoda--> METODA <!--NADKLASE  metod overiding--></b>
<br><br>
Prevladavanje metoda <b>(method overriding)</b> je mehanizam koji omogućava da metod podklase ima istu deklaraciju <!--potpis-->(imena parametara i modifikator pristupa mogu da se razlikuju) ali različitu implementaciju od metoda nadklase.
<xmp class = "primer_ta"> 
class Država
   { 
    ime: string;

    constructor(ime:string)
       { 

        this.ime = ime;

    }

    Znak_dobrodošlice():string
    { 

        return 'Dobro došli u državu ' + this.ime + '.';
    }
   }

   class Grad extends  Država
   {

    Znak_dobrodošlice():string
    { 

        return 'Dobro došli u grad ' + this.ime + '. Želimo Vam prijatan boravak.';
    }	 
   }
   
   class Pokrajina extends Država
   {
       automna:boolean;
   }
   let ks= new Pokrajina('Vojvodina');
   let rs = new Država('Srbija');
   let ue = new Grad('Užice');

   alert(rs.Znak_dobrodošlice());
   alert(ue.Znak_dobrodošlice());
   alert(ks.Znak_dobrodošlice());
</xmp>
U klasi Grad je upotrebljeno prevladavanje metoda dok u klasi Pokrajina nije. Zbog toga pozivi metoda <span class = "primer_text"> Znak_dobrodošlice </span> klasa Država i Pokrajina su isti.
<div class = "napomena">
U zavisnosti od objekta koji je upotrebljen zavisi i koja će od istoimenih metoda biti pozvana. Ako se upotrebi objekat nadklase poziva se metod nadklase, ako se upotrebi objekat podklase poziva se metod podklase.
</div>
<xmp class = "primer_ta"> 
class Banka
{  
Saznaj_kamtnu_stopu(){return 0;}  
}  
  
class Societe_General extends Banka
{  
saznaj_kamtnu_stopu():number{return 8;}  
}  
  
class Intesa extends Banka
{  
saznaj_kamtnu_stopu():number{return 7;}  
}  

class AIK extends Banka
{  
saznaj_kamtnu_stopu():number{return 9;}  
} 
   let a= new Societe_General();
   let b = new Intesa();
   let c = new AIK();

   alert(a.saznaj_kamtnu_stopu());
   alert(b.saznaj_kamtnu_stopu());
   alert(c.saznaj_kamtnu_stopu());
</xmp>
Societe_General, Intesa, AIK klase nasleđuju klasu Banka. Iako sve tri banke nasleđuju metod <span class = "primer_text">saznaj_kamtnu_stopu</span> pozivi metoda objekata ovih klasa vraćaju različite vrednosti
<h3>Modifikatori pristupa</h3>
Bezbednost podataka ima bitnu ulogu u programiranju. Da bi se neki kôd smatrao dobro napisanim osim što obavlja zadatke za koje je namenjen, podaci unutar koda moraju biti zaštićeni od zloupotrebe. To podrazumeva i da se sadržaj koda ne može menjati od strane trećeg lica, unositi vrednosti ili pristupati objektima i drugim strukturama u kodu.
Jedan od načina da se obezbedi sigurnost podataka je upotrebom modifikatora pristupa. Sposobnost klase da kontroliše vidljivost svojih svojstava u odnosu na svojstva druge klasa naziva se enkapsulacija ili skrivanje podataka. Ova osobina se implementira pomoću modifikatora pristupa <b>public</b>, <b>protected</b> i <b>private</b>.
<b>To su ključne reči koje se uvek  navode prve u deklaracijijama promenljivih i metoda.</b><br><br>
<b>PUBLIC</b>
<br><br>
Svojstvima klase koji imaju modifikator pristupa <b>public</b> može se pristupiti iz bilo kog drugog dela koda.  Svojstva klase podrazumevano imaju modifikator pristupa <b>public</b>  osim ako eksplicitno nije navedeno drugačije.
<xmp class = "primer_ta">
class Osoba
   { 
    public ime: string;
    public prezime: string;
    public godine: number;
   }
</xmp>
Ova dva koda imaju potpuno isto značenje.
<xmp class = "primer_ta">
class Osoba
   { 
    ime: string;
    prezime: string;
    godine: number;
   }
</xmp>
<b>PROTECTED</b>
<br><br>
Svojstvima klase koji imaju modifikator pristupa <b>protected</b> mogu pristupiti samo svojstva u okviru iste klase ili svojstva podklasa.
<br><br>
<b>PRIVATE</b>
<br><br>
Svojstvima klase koji imaju modifikator pristupa <b>private</b> mogu pristupiti samo svojstva u okviru iste klase.
<xmp class = "primer_ta">
class Obrazovna_institucija
{ 
    ime: string;
    godina_osnivanja: number;
    broj_nastavnog_osoblja: number;
    private sedište: string;

    constructor(ime:string, broj_nastavnog_osoblja:number)
      { 
        this.ime = ime;
        this.broj_nastavnog_osoblja = broj_nastavnog_osoblja;
      } 

    protected moto():string
    { 
        return ('Znanje je moć!');
    }
      
}

class Fakultet extends Obrazovna_institucija
   { 
       private vrsta_studija: string;
       private broj_redovnih_profesora: number;
       public akreditacija: boolean;
       private broj_studenata: number;

       
       constructor(ime:string, broj_nastavnog_osoblja:number, vrsta_studija: string, akreditacija: boolean)
       { 
           super(ime, broj_nastavnog_osoblja);
           this.vrsta_studija = vrsta_studija;
           this.akreditacija = akreditacija;
       }

       prikazuje_moto_na_ekranu()
       {   
           alert(this.moto());           
       }

       prikazuje_sedište_na_ekranu()
       {   
           alert(this.sedište); // Kompajler izbacuje gresku: Property 'sedište' is private and only accessible within class 'Obrazovna_institucija'       
       }
}
   
let Defektološki = new Fakultet('Fakultet za rehabilitaciju i specijalnu edukaciju', 50, 'master', true);

let p: string = Defektološki.moto(); // Kompajler izbacuje gresku: Property 'moto' is protected and only accessible within class 'Obrazovna_institucija' and its subclasses.
let h: string = Defektološki.vrsta_studija; // Kompajler izbacuje gresku: Property 'vrsta_studija' is private and only accessible within class 'Fakultet'
alert(Defektološki.akreditacija);
</xmp>

Metod <b>moto</b> (pripada klasi Obrazovna_institucija) ima modifikator pristupa <b>protected</b> zbog toga joj je moguće pristupiti u okviru klasa Fakultet ( klasa Fakultet nasleđuje klasu Obrazovna_institucija).  Polje <b>sedište</b> ima modifikator pristupa <b>private</b> zbog toga joj je nemoguće pristupiti u okviru klasa Fakultet.
Metod <b>moto</b> koja pripada objektu Defektološki nemoguće joj je pristupiti u okviru glavnog tela programa jer imam modifikator pristupa <b>protected</b>. Polju <b>vrsta_studija</b> koja pripada objektu Defektološki nemoguće joj je pristupiti u okviru glavnog tela programa jer imam modifikator pristupa <b>private</b>. Polju 
<b>akreditacija</b> moguće je pristupiti u okviru funkcije alert jer imam modifikator pristupa <b>public</b>.
<br><br>
<b>GET I SET METODE</b>
<br><br>
Upotreba modifikatora pristupa doprinosi bezbednosti programa ali istovremeno utiče na vidljivost koda pa time i na njegovu dostpunost. Na ovaj način se smanjuje funkcionalnost koda i izbor implementacije rešenja problema. Jedan od načina da se ovaj problem prevaziđe je
upotrebom <b>get</b> i <b>set</b> metoda. Metod <b>get</b> se koristi da bi se dobila vrednost polja a metod <b>set</b> de se polju dodelila nova vrednost. Za deklaraciju ovih metoda koriste se ključne reči <b>get</b> i <b>set</b>. <br><br>Sintaksa je:
<xmp class = "primer_ta">
get get_polje():tip_polja
   { 

   }

set set_polje(lista_parametara):void
   { 

   }
</xmp>
Dodela imena <b>get</b> i <b>set</b> metodama je izbor pojedinca ali stvar dobre prakse je da bude uniformna kako bi se dobilo na čitljivost koda. Obično imena <b>get</b> i <b>set</b> metoda sadrže ime polja kojem pristupaju.
<xmp class = "primer_ta">
class Telefon     {
    public model: string;
    private proizvođač: string;
    private veličina_ekrana: number;
    private veličina_memorije: number;
    private CPU: string;
    private GPU: string;
    private trajanje_baterije: string;
    protected LTE_4G: boolean;

    constructor(model: string, proizvođač: string, veličina_ekrana: number, LTE_4G: boolean)
    {
        this.model = model;
        this.proizvođač = proizvođač;
        this.veličina_ekrana = veličina_ekrana;
        this.LTE_4G = LTE_4G;
    }

    get get_veličina_ekrana(): number
    {
        return this.veličina_ekrana;
    }

    set set_veličina_ekrana(veličina_ekrana: number)
    {
        this.veličina_ekrana = veličina_ekrana;
    }

    private get get_CPU(): string //Ovaj metod se može koristiti samo u okviru klase a to nema mnogo smisla . (zato što ima modifikator pristupa private)
    {
        return this.CPU;
    }

    set set_CPU(CPU: string)
    {
        this.CPU = CPU;
    }
}
let japanac = new Telefon('Xperia_mini', 'Sony_Ericson', 3.5, false);
alert(japanac.get_veličina_ekrana);
japanac.set_veličina_ekrana =5.5;
alert(japanac.get_veličina_ekrana);
</xmp>
Pozivi metoda <b>get</b> i <b>set</b> su drugačiji od poziva ostalih metoda ili funkcija jer nemaju <span class = "primer_text"> () </span>. To su specijalni metodi.  Metod <b>get</b> nema parametre a povratna vrednost mu je vrednost polja.
Metod <b>set</b> ima jedan parametar ali nema povratnu vrednost niti se tip povratne vrednosti navodi. Prilikom poziva <b>get</b> i <b>set</b> metoda sintaksa je:<br><br>
<xmp class = "primer_ta"> ime_objekta.ime_get_metode  </xmp>
<xmp class = "primer_ta"> ime_objekta.ime_set_metode = željena_vrednost_polja</xmp>
<div class = "napomena">Moguće je dodeliti <b>get</b> i <b>set</b> metodama modifikatore pristupa <b>protected</b> i <b>private</b>  ali to u praksi ima veoma malo smisla. Druge metode se mogu pozivati unutar <b>set</b> metoda.</div>
<b>READONLY</b>
<br><br>
Modifikator <b>readonly</b> se koristi da bi se naznačilo da je neku vrednost polja moguće samo čitati a ne i menjati. Ključna reč <b>readonly</b> se navode posle modifikatora pristupa. <br><br>Sintaksa je: <span class = "primer_text"> readonly ime_polja  </span>  
<xmp class = "primer_ta">
class Klasa
{ 
    public readonly ime_polja_1: string;
    public readonly ime_polja_2: number;

    constructor(ime_polja_1:string,ime_polja_2: number )
       { 
        this.ime_polja_1 = ime_polja_1;
        this.ime_polja_2 = ime_polja_2;
       }
}

let O = new Klasa('Intel', 4);//Može da se čita ali ne i menja

alert(O.ime_polja_1);

O.ime_polja_1 = 'AMD';//Cannot assign to 'ime_polja_1' because it is a constant or a read-only property.
</xmp>
U poslednjoj liniji koda kompajler izbacuje grešku jer se pokušava dodeliti nova vrednost polju koje je <b>readonly</b> ili konstanta.<br><br>
<b>STATIC</b>
<br><br>
Polja i metode koje dele svi objekti jedne klase nazivaju se statička. One se koriste da označe svojstva koja su zajednička za sve objekte. Da bi neko polje ili metod bilo statičko koriste se ključna reč <b>static</b>. Ključna reč <b>static</b> se navodi posle modifikatora pristupa i pre ključne reči <b>readonly</b>.<br><br>Sintaksa:<span class = "primer_text">static ime_polja_metoda</span> 
<xmp class = "primer_ta">
class Pas
{

    static carstvo: string = 'Animalia';
    static tip: string = 'Chordata';
    static klasa: string = 'Mammalia';

    ime: string;
    poreklo: string;
    težina: number;
    visina: number;

    constructor(ime:string,poreklo:string)
      { 
        this.ime = ime;
        this.poreklo = poreklo;          
      }

    static lavež()
     { 
        alert('Vuvuvu! Vuv! (U prevodu "Ja sam dobar pas")');    
     }

}

let Lesi = new Pas('Lesi', 'Azija');
let Bleki = new Pas('Bleki', 'Afrika');

alert('Svaki pas pripada carstvu ' + Pas.carstvo );

Pas.lavež();
</xmp>
Sintaksa za poziv statičkog metoda je: <span class = "primer_text">ime_klase.ime_statičkog_metoda(list_argum)</span>.<br><br> Sintaksa za pristup vrednosti statičkog polja je: <span class = "primer_text"> ime_klase.ime_statičkog_polja</span>. 
<div class = "napomena">
Prilikom kreiranja objekta u memoriji se alocira prostor za svako polje i metod. Tako da za npr. 100 objekata klase Osoba imamo 100 promenljivih koje čuvaju polje ime svake od 100 osoba. Ako bi se u klasi Osoba polje ime označilo <b>static</b> onda bi svih sto objekata polju ime pristupalo na jednoj lokaciji u memoriji.(umesto na 100 lokacija).
Na ovaj način se čuva memorijski prostor. </div>
<h3>Apstraktna klasa</h3>
Klasa čiji objekti se ne mogu napraviti<!--Instanciras--> naziva se apstraktna klasa. Klasa je apstraktna i ako sadrži jedan ili više apstraktnih metoda. Metod je apstraktan ako nema implementaciju. Apstraktni metodi se implementiraju u podklasi koja nije apstraktna. 
Da bi se klasa ili metod deklarisali kao apstraktni koristi se ključna reč <b>abstract</b>. <br><br>Sintaksa je:<br><br>
<span class = "primer_text"> abstract ime_klase </span><br><br>
<span class = "primer_text"> abstract ime_metoda</span> 
<br><br> Kod metoda ključna reč <b>abstract</b> se navodi posle modifikatora pristupa.
<xmp class = "primer_ta">
abstract class Jezik
{ 

    ime_pisma: string;
    broj_govorornika: number;
    broj_karaktera: number;

    constructor(ime_pisma: string, broj_govorornika: number)
    { 
        this.ime_pisma = ime_pisma;
        this.broj_govorornika = broj_govorornika;
    }
    
    abstract predstavljanje(ime:string): void;
}

class Japanski extends Jezik
{ 
    
    
    predstavljanje(ime:string)
    { 
        alert('私の名前を挨拶するのは'+ ime+'。お会いできてうれしいです。');
    }
}

class Srpski extends Jezik
{ 
       
    predstavljanje(ime:string)
    { 
        alert('Pozdrav moje ime je '+ ime+' i drago mi je da te upoznajem.');
    }
}

let j = new Japanski('Kanđi, Hiragana, Katakana', 125);
let s = new Srpski('Ćirilica, Latinica', 12);

j.predstavljanje('Amaterasu');

s.predstavljanje('Dušan');
</xmp>
Apstraktnu klasu Jezik nasleđuju dve klase (Japanski, Srpski) koje sadrže različite implementacije apstraktnog metoda pozdravljanje.
<div class = "napomena">  Apstraktna klasa može da poseduje metode , polja i konstruktore. Ona može da bude i nadklasa i podklasa. Ako podklasa apstraktne klase ne implementira apstraktan metod kompajler će izbaciti grešku da metod nije implementiran. 
Uprkos tome moguće je praviti objekte podklase i kôd će se izvršavati 'normalno' sve dok u sebi ne sadrži  poziv apstraktnog metoda. Zbog ovoga treba biti oprezan pri implementaciji apstraktnih metoda jer greška će ostati u kodu uprkos tome što prividno izgleda da program radi normalno.
</div>
<div class = "zadatak"><b>Zadatak8:</b><br>
a) Napisati klasu <b>Bankovni račun</b> koja treba da sadrži (može sadžati i druga svojstva) <b>polja ime</b>, <b>prezime</b>, <b>šifra</b>, <b>stanje na računu</b>, <b>dozvoljen minus</b> i metode <b>podizanje sa računa</b> i <b>provera stanje računa</b>. Konstruktor klase  ima parametre ime, prezime, stanje na računu i šifra.  Polja stanje na računu i šifra treba da bude dostupna samo svojstvima klase. Vrednost polja šifra može samo da se čita ne i menja.
Metoda stanje na računu vraća stanje računa korisnika nakon unete ispravne šifre. Metod podizanje sa računa nakon unete šifre vraća traženu sumu  ako: 
<ul style="list-style-type:circle">
  <li>Stanje na računu je veće od tražene sume</li>
  <li>Stanje na računu sa dozvoljenim minusom je veće od tražene sume i korisnik je odobrio da ulazak u dozvoljen minus</li>
  <li>Vraća poruku da korisnik nije u mogućnosti da podigne traženu sumu </li>
</ul> <br>
Zadatak testirati na primeru.
<br><br>
b) Napisati klasu <b>Kompleksni broj</b> koja sadrži polja <b>x</b> i <b>y</b> kao i njihove get i set metode. Konstruktor ima parametre x i y. Napisati metod koji vraća zapis kompleksnog broja. Napisati metod koji vraća modul kompleksnog broja.
Napisati statičke metode za sabiranje, oduzimanje, deljenje i množenje kompleksnih brojeva. Napisati statički metod koji vraća argument kompleksnog broja u stepenima. Napisati statički metod koji vraća konjugovani kompleksni broj.<br><br>
c) Napisati klasu <b>Trougao</b> koja sadrži polja <b>a</b>, <b>b</b> i <b>c</b>. Klasa treba da sadži konstruktor koji inicijalizuje vrednost stranica i metode <b>površina </b> i <b>obima</b>. Pored ove klase treba napisati klase <b>Jednakostranični</b>, <b>Jednakokraki</b> i <b>Pravougli</b> koje nasleđuju klasu <b>Trougao</b>. Svaka od ovih klasa treba da ima svoj metod <b>površina</b> koji pri pozivu prevladava metod klase <b>Trougao</b>.
</div>

