<h1>Funkcije</h1>
<br> 
Funkcija predstavlja blok koda koji je logički organizovan tako da vrši neki zadatak. Jednom kada se definiše može se više puta pozivati što kôd čini ponovo upotrebljvim. Funkcije igraju bitnu ulogu u programiranju što uključuje i TypeScript.
One doprinose modularnosti programa i čine program preglednim i lakšim za održavanje. <br><br> Sintaksa zdeklaracije i definicije funkcije je:
<xmp class = "primer_ta">  
 function Ime_Funkcije (parametar_1:tip_parametra_1, parametar_2:tip_parametra_2, ... , parametar_n:tip_parametra_n):tip_povratne_vrednosti
   {
   //iskazi
   
   return povratna_vrednost;
   }
 </xmp>
 <ul style="list-style-type:circle">
  <li>Da bi deklarisali funkciju koristi se ključna reč <b>function</b></li>
  <li>Deklaracija funkcije predstavlja <!--kôd ne može da stane -->:<span class = "primer_text"> function Ime_Funkcije (...):tip_povratne_vrednosti </span><br> dok ostatak tj. blok koda predstavlja definiciju ili telo funkcije (koristi se još termin implementacija).</li>
  <li><span class = "primer_text">Ime_Funkcije</span> predstavlja ime koje želimo da funkcija ima.</li>
  <li>Promenljive <span class = "primer_text">parametar_1, ..., parametar_n </span>  su promenljive koje se koriste u telu funkcije i predstavljaju vrednosti koje se prosleđuju funkciji pri njenom pozivu.</li>
  <li>Vrednost koju funkcija vraća posle poziva naziva se <span class = "primer_text">povratna vrednost</span>.</li>
  <li>Ključna reč <b>return</b> se koristi kako bi naznačili funkciji koja vrednost predstavlja povratnu vrednost. Ako funkcija nema povratnu vrednost onda se ne koristi <b>return</b> a <span class = "primer_text">tip_povratne_vrednosti</span> je void.</li>
  <li>Poziv funkcije <span class = "primer_text">Ime_Funkcije</span> predstavlja <span class = "primer_text">Ime_Funkcije(arg_1,arg_2, ... arg_n)</span></li>
</ul> 
 
 <div class = "napomena">Promenljive u deklaraciji funkcije se nazivaju parametri. Promenljive koje se prosleđuju kao vrednosti funkcije pri njenom pozivu nazivaju se argumenti. Potpis funkcije definiše ulaz i izlaz funkcije ili metoda. On sadrži tipove parametara i povratne vrednosti<!--Može da uključuje povratnu vrednost, tip povratne vrednosti, parametre i njihovi tipovi-->.</div>
 
 Pri deklaraciji funkcije moguće je izostaviti <span class = "primer_text">tip_parametra</span> i <span class = "primer_text">tip_povratne_vrednosti</span> , u tom slučaju kompajler smatra da su tipa <b>any</b>.
 
 <xmp class = "primer_ta">  
 function kvadrat_broja(x:number):number
{ 
  return x * x;
}
alert(kvadrat_broja(11));
 </xmp>
 
Kada nisu deklarisani tipovi kompajler će na osnovu argumenta da odredi o kom se tipu radi. Kompajler svaki parametar ili povratnu vrednosti koja nema deklarisan tip deklariše da je tipa any.
 
 <xmp class = "primer_ta">  
 function kvadrat_broja(x)
{ 
  return x * x;
}
alert(kvadrat_broja(11));
 </xmp>
<div class = "napomena">Kada nije poznat tip povratne vrednosti ili povratna vrednost funkcije može da ima više tipova tada je najbolja izostaviti tip povratne vrednosti u deklaraciji funkcije. U tom slučaju će tip povratne vrednosti funkcije automatski biti deklarisan kao any. </div>
 <xmp class = "primer_ta">  
function f(x: number)
{
  if (x == 1)
    return 7;
  else if (x == 2)
    return 'Ovo je string';
  else return false;  
}

alert(f(1)+ ' je tipa ' + typeof(f(1)));
alert(f(2)+ ' je tipa ' + typeof(f(2)));
alert(f(100)+' je tipa '+ typeof(f(100)));
</xmp>
Ovo je primer funkcije kojoj povratna vrednost može da bude različitog tipa.
<h3>Tip funkcije</h3>
Kao što promenljive imaju tipove tako i funkcije imaju svoje tipove. Tip funkcije se sastoji od dva dela kojima je određen: prvi deo predstavlju tipovi parametara funkcije a drugi deo predstavlja tip povratne vrednosti. U nastavku je napravljeno poređenje između deklaracije promenljive i deklaracije funkcije.<br><br> 
<span class = "primer_text"> let moja_promenljiva:tip_promenljive </span><br><br>
<span class = "primer_text"> let moja_funkcija:(p_1:tip_p_1, ..., p_n:tip_p_n) => tip_povratne_vrednosti </span><br><br>
Za deklaraciju ove funkcije nije korišćena klučna reč <b>function</b> već lambda operatora <span class = "primer_text">=></span>.<br>
Kao što promenljivoj možemo da dodelimo vrednost pomoću operatora <span class = "primer_text">=</span> tako možemo i funkciji definiciju na osnovu koje računa povratnu vrednost.<br><br>
<span class = "primer_text"> let moja_promenljiva:tip_promenljive = vrednost_promenljive </span><br><br>
<span class = "primer_text"> let moja_funkcija:(p_1:tip_p_1,..., p_n:tip_p_n) => tip_povratne_vrednosti = function(p_1:tip_p_1,...,p_n:tip_p_n){//skup_iskaza;return povratna_vrednost;}</span><br><br>
Ako bi prethodni primer bio zapisan pomoću ove sintakse:
 <xmp class = "primer_ta">  
let kvadrat_broja:(x:number) => number =
function (x:number)
{ 
  return x * x;
 }
alert(kvadrat_broja(11));
 </xmp>
Operator lambda <span class = "primer_text">=></span> se može iskoristi umesto ključne reči <b>function</b> kako bi deklarisali i definisali funkciju.
 <xmp class = "primer_ta">  
let kvadrat_broja =(x:number): number =>
{ 
  return x * x;
 }
alert(kvadrat_broja(11));
 </xmp>
 Ovako deklarisane i definisane funkcije se još nazivaju lambda funkcije zbog upotrebe lambda operatora.
 <h3>Vrste parametara u funkciji</h3>
 U TypeScript-u, za svaki parametar koji je deklarisan u funkciji očekuje se argument. Vrednost argumenta može da bude i <b>null</b> ili <b>undefined</b>. Kompajler pri pozivu funkcije proverava da li broj argumenata fukcije odgovara broju njenih parametara. U programskom jeziku TypeScript postoje četri vrste parametara:
 obavezni, neobavezni (optional), podrazumevani (default) i niz parametara(rest).<br><br>
 <b>NEOBAVEZNI PARAMETRI</b><!--Mislim da je u ovom slučaju prikladnije koristiti engleske reči, uvek mogu zameniti --><br><br>
 Da bi neki parametar funkcije označili kao neobavezan tj. da nije obavazno da funkciji eksplicitno prosledimo argument, koristimo znak <span class = "primer_text">?</span>. Znak <span class = "primer_text">?</span> se navodi<!--dodaje --> odmah posle imena parametra. U nastavku je neveden primer koji prikazuje upotrebu neobaveznih parametara.
 <xmp class = "primer_ta">  
 function moja_funkcija (ime:string, prezime:string, srednje_ime?:string): string
   {
        let r:string;

        if(srednje_ime)
        return r=ime + ' ' + srednje_ime + ' ' +prezime;
        else		
        return r=ime + ' ' + prezime;
   } 
   alert(moja_funkcija('Petar','Petrović','Njegoš'));
   alert(moja_funkcija('Fridrih','Gaus'));
 </xmp>
 Ovaj primer sadrži dva poziva funkcije moja_funkcija. Prvi poziv funkcije sadrži tri argumenta dok drugi poziv funkcije dva jer nije unet treći argument koji je namenjen za neobavezni parametar.
 <div class = "napomena">U deklaraciji funkcije neobavezni parametar ne može da stoji ispred obaveznog parametra. Zbog toga se navodi kao poslednji na listi parametara. Ako se funkciji ne prosledi argument koji je namenjen neobaveznom parametru onda kompajler funkciji prosleđuje taj argument koji ima vrednost <b>undefined</b>. Tako da funkciji uvek bude prosleđen broj argumenata koji odgovara broju njenih parametara.</div>
 <xmp class = "primer_ta">  
 function opasna_funkcija(x:number, y?:number):any
  { 
   if(y==undefined)
   return typeof(y);
   else
   return x+y;
}
 alert(opasna_funkcija(999,1)); 
 alert(opasna_funkcija(999));
 </xmp>
 Kao što je u primeru prikazano ako se funkciji eksplicitno ne prosledi argument neobaveznog parametra onda to kompajler uradi. Korišćenjem operatora typeof može se proveriti da je vrednost tog argumenta baš undefined. Pošto je undefined podtip svakog tipa pa nema konflikta između tipa argumenta i tipa njegovog parametra.
 <br><br>
 TypeScript dozvoljava da jedna deklaracija funkcije ima više neobaveznih parametara koji se navode jedan za drugim. U situaciji kada se jednom neobaveznom parametru prosledi argument a drugom ne kompajler ne može da prepozna kom neobaveznom parametru je namenjen taj argument. Zbog toga kompajler prosleđuje argument prvom dostupnom neobaveznom parametru na listi.
 Ovaj problem se rešava tako što neobaveznim parametrima kojima ne želimo da prosledimo konkretnu vrednost prosledimo vrednost <b>undefined</b>.
  <xmp class = "primer_ta">  
 function opasna_funkcija(x:number, y?:number, z?:number,d?:number):any
  { 
   if(y==undefined)
   return typeof(y);
   else
   if(d==undefined)
   return typeof(d);
   else return x+y+d;
}
 alert(opasna_funkcija(999,1,undefined,121)); 
 alert(opasna_funkcija(999));
 </xmp>
 <b>PARAMETRIM SA PODRAZUMEVANIM VREDNOSTIMA</b> <br><br>
 Parametri kojima je dodeljena vrednost ( kao što dodeljujemo promenljivima tokom pisanja programa) u deklaraciji funkcije nazivamo parametri sa podrazumevanim vrednostima. Ako se parametru koji ima podrazumevanu vrednost ne prosledi argument funkcije ili mu se prosledi vrednost <b>undefined</b> onda će njegova vrednost u telu funkcije baš biti njegova podrazumevana vrednost.
 <xmp class = "primer_ta"> 
 function moja_funkcija (ime:string, prezime:string, srednje_ime:string = 'Nemanjić'): string
   {
        let r:string;

        if(srednje_ime)
        return r=ime + ' ' + srednje_ime + ' ' +prezime;
        else		
        return r=ime + ' ' + prezime;
   } 
   alert(moja_funkcija('Petar','Petrović','Njegoš'));
   alert(moja_funkcija('Fridrih','Gaus'));
 </xmp>
   <xmp class = "primer_ta"> 
 function opasna_funkcija(x:number, y:number = -998):any
  { 
   if(y==undefined)
   return typeof(y);
   else
   return x+y;
}
 alert(opasna_funkcija(999,1)); 
 alert(opasna_funkcija(999,undefined));
 </xmp>
 <b>NIZ PARAMETARA</b> <br><br>
 Niz parametara (rest parameters) se koriste kada funkciji želimo da prosledimo više argumenata istog tipa ili nismo sigurni koliko će argumenata kasnije funkciji biti prosleđeno. Da bi neki parametar bio deklarisani kao niz parametara koriste se 
 <span class = "primer_text"> ... </span> koje stoje ispred imena niza parametara posle kojeg ide tip vrednosti i <span class = "primer_text"> [] </span> kako bi naglasili da se radi o nizu parametara. Sintaksa je: <span class = "primer_text"> ... ime:tip[] </span> <br><br>Zapis deklaracije funkcije koji sadrži niz parametara<br><br>
 <span class = "primer_text"> function moja_funkcija(...niz_parametara:tip_niza_parametara[], običan_parametar:tip_običnog_parametra):tip_povratne_vrednosti </span>
 <div class = "napomena">Funkcija svoje argument čuva u okviru objekta <b>arguments</b>. Objekat <b>arguments</b> je lokalna promenljiva koja postoji samo u okviru tela funkcije. Argumentima funkcije možemo da pristupamo kao arguments[0], arguments[1] itd.
 u zavisnosti koliko je u deklaraciji funkcije navedeno parametara. Objekat <b>arguments</b> nije niz ali poseduje određene osobine koje postoje kod niza. Jedan od načina da se pristupi parametrima u okviru niza <span class = "primer_text"> niz_parametara</span> je korišćenjem for petlje. </div>
  <xmp class = "primer_ta">  
 function funkcija_br_99 (x:number, y: number,... NIZ:string[]):string
 {
 let s:string='Vrednosti koje smo prosledili funkcija_br_99 su: '+ x + ', ' + y + ', ';

 for (let i = 0; i < NIZ.length;i++)
   {
   s = s + NIZ[i] + ' ,';
   }

 s = s.substring(0, s.length - 1);

 return s;
 }
alert(funkcija_br_99(5, -4, 'Ove', 'stringove', 'smo', 'prosledili', 'parametru', 'koji', 'je', 'niz', '.', 'Možemo', 'da', 'ovako', 'nastavimo', 'doveka.'));
 </xmp>
 U ovom primeru <span class = "primer_text">funkcija_br_99</span> ima niz parametara koji se zove NIZ i tipa je string. U funkciji je korišćena for petlja kako bi bilo pristupljeno svim članovima niza NIZ. Funkcija substring se koristi da se od početnog string dobije neki njegov deo.
 <div class = "napomena">Niz parametara se uvek deklariše na kraju liste parametara i ne može sadržati elemente različitih tipova. Deklaracija funkcije može da sadrži samo jedan niz parametara. Ako se pri pozivu funkcije ne proslede argumenti nizu parametara onda će kompajler napraviti prazan niz.</div>
 <h3>Anonimne funkcije</h3>
 Funkcije koje nemaju ime nazivaju se anonimne funkcije. One se deklarišu tokom pokretanja programa jer nemaju ime koje je potrebno za deklaraciju funkcije. Jedini način da se pristupi anonimni funkcijama posle njihovog kreiranja jeste da im se dodeli promenljiva.
 Anonimne funkcije poseduju parametre, telo funkcije i povratnu vrednost kao i svaka standardna funkcija. <br><br>Sintaksa za anonimnu funkciju je:<br><br>
 
 <span class = "primer_text">let ime_promenljive = function( parametri ):tip_povratne_vrednosti{...}</span><br>
 Primer anonimne funkcije.
 <xmp class = "primer_ta">  
let anonimna_funkcija=function(...brojevi:number[]):number
  {
  let s: number=0;

  for (let i = 0; i < brojevi.length; i++)
  { 
    s = s + brojevi[i]; 
  }  
  
  return s / brojevi.length;
}
alert('Srednja vrednost  vrednosti argumenata anonimne funkcije je ' + anonimna_funkcija(1,56,89,67,12));
alert('Srednja vrednost vrednosti argumenata anonimne funkcije je ' + anonimna_funkcija(13,21,1,0,8,8,12,999)); 
 </xmp>
<h3>Parametarske funkcije</h3>
Parametarska funkcija(<b>Callback function</b>) je funkcija koja je prosleđena drugoj funkciji kao parametar. U programskom jeziku TypeScript funkcije su tipa <b>Object</b> i tretiraju se kao i svi drugi objekti (String, Array, Number, itd.) pošto su i same objekti.
 To znači da se mogu čuvati u promenljivama, proslediti kao argument funkcijama, biti kreirane u okviru druge funkcije ili vraćene kao povratna vrednost funkcije. Iz istog razloga funkcije možemo tretirati kao parametre neke druge funkcije jer su parametri u suštini promenljive.
 <br><br>Potpuna deklaracija funkcije koja za parametar ima funkciju je:<br><br>
 <span class = "primer_text"> function moja_funkcija (par_fun:(...) => tip_pov_vrednosti): tip_pov_vrednosti</span><br><br>
 
 Moguće je izostaviti iz deklaracije parametarske funkcije tip povratne vrednosti, tip parametara pa čak i same parametre. Ovo se obično radi u situacijama kad nije poznat broj parametara funkcije koja se prosleđuje funkciji <span class = "primer_text"> moja_funkcija</span> ili je želja da se ostavi mogućnost da mogu da se proslede funkcije sa različitim brojem parametara.
 <br><br>
 Onda je sintaksa:
 <br><br>
 <span class = "primer_text"> function moja_funkcija ( par_fun): tip_pov_vrednosti</span><br>
 <div class = "napomena">Kao i kod promenljivih potpuna deklaracija funkcija je najpoželjnija jer smanjuje mogućnost da dođe greške u daljem pisanju koda. Zbog toga preporuka je da pisanje koda  bude što više tipizirano uključujući i deklaracije funkcija a da pritom se zadrži željena funkcionalnost koda.</div>
 U nastavku je prikazani su primeri ova dva pristupa.
 <xmp class = "primer_ta">  
function stepen_broja(p, q)
{ 
  let s = p;
  for (let i = 0; i < q ;i++)
    {
    s = s * p; 
    }
  return s;
}

function f2(p, q)
{ 
  return p - q;
}

function f(x1:number,x2:number, par_funkcija:(y1:number,y2:number) => number)
{ 

  return par_funkcija(x1, x2);

}

alert(f(2, 5, f2));
alert(f(2, 5,stepen_broja));
 </xmp>
 Ako se izostavi potpuna deklaracija parametarkse funkcije.
  <xmp class = "primer_ta">  
function stepen_broja(p, q)
{ 
  let s = p;
  for (let i = 0; i < q ;i++)
    {
    s = s * p; 
    }
  return s;
}

function f2(p, q)
{ 
  return p - q;
}

function f3(x, y, z=5)
{ 
  return x + y + z;
}


function f(x1:number,x2:number, par_funkcija)
{ 

  
  return par_funkcija(x1, x2);

}

alert(f(2, 5, f2));
alert(f(2, 5, stepen_broja));
alert(f(2, 5, f3));
 </xmp>
 U ovom primeru funkciji <b>f</b> je moguće proslediti kao argument funkciju  koja ima 2 ili 3 parametra. Ovo je moguće uraditi jer parametarska funkcija funkcije <b>f</b> nema potpunu deklaraciju tj. nisu navedeni parametri funkcije <span class = "primer_text"> par_funkcija</span>.<br>
 <div class = "napomena">Kada se funkcija prosleđuje kao argument navodi se samo njeno ime. Ako se prosledi funkcija sa njenim argumentima onda se prosleđuje vrednost i komprajler će javiti grešku da očekuje funkciju a ne vrednost. Ne postoji ograničenje koliko deklaracija funkcije može sadržati parametarskih funkcija niti kojim redosledom moraju biti navedene.</div>
 Primer funkcije koja kao povratnu vrednost vraća drugu funkciju.

<xmp class = "primer_ta">  
function f()
{ 

  function f1()
   {
    return 'Ovo je funkcija koja za povratnu vrednost ima funkciju';  
   }
   
  return f1();
  
}


alert(f());
 </xmp>
 <h3>Preopterećenje funkcije</h3>  <!--Ili polimorfne funkcije jer function overloading je vrsta polimorfizma tj. ad hoc polimorfizma -->
 U programskom jeziku TypeScript funkcija ima osobinu da se ponaša drugačije u zavisnosti od argumenata koji su joj prosleđeni. Posledica toga je da u programu možemo da imamo više funkcija sa istim imenom a različitim implementacijama. Ova osobina funkcija se naziva preopterećenje funkcije ili na engleskom <b>function overloading</b>.
 Da bi neku funkciju preopteretili potrebno je uraditi sledeće:<br><br>
 <b>-Prvi korak- </b> Deklarisati više funkcija koje imaju isto ime ali različite potpise. Potpisi funkcija se razlikuju ako je ispunjen jedan od naredna tri uslova.<br>
 <ul style="list-style-type:circle">
  <li>Deklaracije funkcije imaju isti broj parametara ali jedan od druge se razlikuju makar u jednom tipu parametra</li>
  <li>Razlikuju se po broju parametara</li>
  <li>Razliku se po rasporedu parametara tj. po tipu parametra koji odgovara mestu na listi parametara</li>
</ul> 
<b>-Drugi korak- </b>Navodi se još jedna deklaracija funkcije sa istim imenom iza koje odmah ide definicija funkcije. Tipovi parametara ove funkcije treba da budu <b>any</b> ako se tipovi razlikuju u prethodnim deklaracijam funkcije . Ako se ne razlikuju, tipovi parametara funkcije su isti kao u prethodnim deklaracijama funkcije. Isto pravilo se odnosi i za tip povratne vrednosti funkcije.
Ako se prethodne deklaracije funkcija razlikuju u broju parametara onda broj obaveznih parametara jednak je broju parametara deklaracije funkcije koja ima najmanji broj parametara. Broj neobaveznih parametara jednak je razlici broja parametara deklaracije funkcije koja ima najviše parametara i deklaracije funkcije koja ima najmanje parametara.
<br><b>-Treći korak- </b> Napraviti poziv funkcije kako bi proverili da li je preopterećena.<!--Treći korak suvišan? -->
<br><br>U naredna dva primera je prikazana upotreba preopterećenja funkcije.
<xmp class = "primer_ta">  
function sabiranje (x: string, y: string): string;
function sabiranje (x: number, y: number): number;

function sabiranje(x: any, y: any): any
{
return x + y;
}

alert('Prvi poziv funkcije sabiranje sabira  brojeve i rezultat je: ' + sabiranje(1,99));
alert('Drugi poziv funkcije sabiranje sabira  string-ove i rezultat je: ' + sabiranje('Užice je najveći grad ', 'Zlatiborskog okruga.'));
</xmp>
<xmp class = "primer_ta">  
function mera(x:string): string;
function mera(x:number): string;
function mera(x:number, x1:number): string;
function mera(x: number, x1: number, x2: number): string;

function mera(x: any, x1?: number, x2?: number): string
{
      
  if (arguments.length == 1 && typeof (x) == 'string') 
    return 'Dužina stringa je: ' + x.length;
  else if (arguments.length == 2)
    return 'Površina pravougaonika je: ' + x * x1;
  else if (arguments.length == 3)
    return 'Zapremina kvadra je: ' + x * x1* x2;
  else
    return 'Dužina stranice je: ' + x;        
   }
alert(mera(6));
alert(mera('Ijejasu Tokugava'));
alert(mera(11, 17));
alert(mera(2, 4, 8));
</xmp>
<div class = "napomena"> Funkcija koje je preopterećena ima više deklaracija ali samo jedno telo funkcije. U slučaju da je više funkcija sa istim imenom deklarisano
 i definisano kompajler će javiti grešku <b>duplicate function implementation</b>. Za razliku od nekih drugih programskih jezika gde više deklaracija istoimene funkcije podrazumeva i više implementacija, u programskom jeziku TypeScript to nije moguće. Kada se TypeScript kôd transkompilira u JavaScript kod potpisi deklaracija funkcija se ne razlikuju. Treba razlikovati pojmove preopterećenja funkcije i osobine parametara funkcije. Neka od rešenja problema moguće je implementirati i preko jedne i preko druge osobine.</div>
 <h3>Rekurzivne funkcije</h3>
 Funkcija je rekurzivna ako poziva samu sebe. Postoje dve vrste rekurzije posredna i neposredna.<!--Indirektan i direktna--> Kod neposredne rekurzije funkcija u svojoj implementaciji sadrži poziv same sebe. Kod posredne rekurzije funkcija u svojoj implementaciji sadrži poziv rekurzivne funkcije koja u svojoj implementaciji sadrži poziv početne funkcije (ili poziv rekurzivne funkcije koja u svojoj implementaciji sadrži  poziv početne funkcije).
 Rekurzivne funkcije predstavljaju bitan koncept u programiranju. Jedna od njihovih upotreba je u implementaciji grupe algoritama koja ima naziva podeli pa vladaj (divide and conquer). Takođe imaju veliku upotrebu u pristupu rešavanja problema koji se zove dinamičko programiranje.
 Rekurzivne funkcije mogu da se upotrebe umesto petlje u kodu jer mogu da vrše istu ulogu.<br><br>
 
 Svaka rekurzivna funkcija da bi bila upotrebiljiva u kodu mora da ima jedan ili više <b>bazičnih slučajeva</b> koji zajedno obezbeđuju izlaz iz rekurzije. U suprotnom bez <b>bazičnih slučajeva</b> svaka rekurzivna funkcija bi postala beskonačna petlja.
 <b>Bazični slučajevi</b> naglašavaju rekurzivnoj funkciji u kom slučaju treba da prestane sa pozivima same sebe i tom prilikom se vraća povratnu vrednost koja je konstantna. Implementacija <b>bazičnih slučajeva</b> se vrši pomoću iskaza <b>if</b>.
 <br><br>
 <!--Ne znam bas kako bi ovde opisao sintaksu rekurzivne funkcije? -->
 U nastavku navedeni su primeri direktnih i indirektnih rekurzivnih funkcija.
 <xmp class = "primer_ta">  
let unos1 = document.createElement("input");
document.body.appendChild(unos1);

let dugme1 = document.createElement("button");
document.body.appendChild(dugme1);
dugme1.textContent = "Računaj";

dugme1.onclick = function () {

     let i: number=+unos1.value; 
     alert(faktorijel(i));

  } 



function faktorijel(n: number): number
  { 
    if (n == 0 || n == 1)// bazični slučaj
        return 1;
    else return n*faktorijel(n - 1);
  }
</xmp>
Neposredna rekurzivna funkcija  koja računa faktorijel unetog broja.
 <xmp class = "primer_ta">  
let unos1 = document.createElement("input");
document.body.appendChild(unos1);
let unos2 = document.createElement("input");
document.body.appendChild(unos2);

let dugme1 = document.createElement("button");
document.body.appendChild(dugme1);
dugme1.textContent = "Računaj";

dugme1.onclick = function () {

    let i: number = +unos1.value; 
    let j: number = +unos2.value;
     alert(uzajamno_prosti(i,j));

  } 




function uzajamno_prosti(p:number, q:number) {
    if (q == 0)
        return (p == 1);
   return uzajamno_prosti(q, p % q);
}

</xmp>
Neposredna rekurzivna funkcija  koja ispituje da li su dva uneta broja uzajamno prosta.
 <xmp class = "primer_ta">  
let unos1 = document.createElement("input");
document.body.appendChild(unos1);

let dugme1 = document.createElement("button");
document.body.appendChild(dugme1);
dugme1.textContent = "Računaj";

dugme1.onclick = function () {

    let i: number = +unos1.value; 

     alert(paran(i));

  } 



function paran (x: number): boolean
     {
    if (x == 0)
        return true;
    else
      return neparan(Math.abs(x) - 1);

    }

 

function neparan(x: number): boolean
    {
       if (x == 0)
         return false;
       else
         return paran(Math.abs(x) - 1);
    }

</xmp>
Dve posredno rekurzivne funkcije  koja ispituju da li je unet broj paran ili neparan.
<div class = "napomena">Rekurzivne funkcije mogu biti veoma korisne u implementaciji rešenja problema ali treba biti oprezan prilikom njihovg korišćenja. Može se javiti problem da rekurzivna funkcija postane beskonačna petlja.  Prilikom korišćenja rekurzivnih funkcija može doći do nestanka radne memorije jer
 rekurzivne funkcije mogu da imaju jako veliku složenost, dosta njih eksponencijalnu. Verovatnoća da se ovo desi se povećava što više poziva rekurzivna funkcija ima. Zbog toga treba uvesti brojač i postavit gornju granicu koliko rekurzivnih poziva funkcija može obaviti nako čega se automatski izlazi iz rekurzije. Takođe treba odlučiti
 kada je efikasno koristiti rekurzivne funkcije jer npr. prolazak kroz niz korišćenjem petlje je brže nego korišćenje rekurzivne funkcije.</div>
 <div class = "zadatak"><b>Zadatak7:</b><br>
a)Napisati program koji rekurzivno računa približnu vrednost zlatnog preseka. U program se unosi prirodan broj n koji predstavlja broj iteracija rekurzije.
<br>
b)Napisati program koji za uneti prirodan broj n ispisuje n-ti član fibonačijevog niza.<br>
c)Napisati funkcijiju koja nema ograničen broja parametara. Parametri su tipa string. Funkcija računa ukupan broj karaktera svih unetih argumenata.
</div>
