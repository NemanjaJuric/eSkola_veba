
<h1>ES6 Loops</h1>

Ponekad, određene instrukcije zahtevaju izvršavanje veći broj puta. Petlje su idealan način da se to uradi. Petlja predstavlja skup instrukcija koje se moraju ponoviti. 
Konceptualno, razlikujemo dve vrste petlji, koje se razlikuju po načinu na koji se određuje broj iteracija. Određene i neodređene.
<br>

<br>
<h2>Definite Loops</h2>
Određena petlja ima definitivan / fiksni broj ponavljanja. U ES6 postoje tri vrste određenih petlji koje su navedene dole:<br><br>
<br>
<table class="tabela">
<thead>
<tr>
<th>Petlja</th>
<th>Opis</th>
</tr>
</thead>
<tbody>
<tr>
<td> for( ; ; ) petlja</td><td>Izvršava blok naredbi određeni broj puta.</td>
</tr>
<tr>
<td> for...in  petlja</td><td>Iterira(prolazi) kroz polja objekta.</td>
</tr>
<tr>
<td> for...of petlja</td><td>Iterira kroz elemente niza.</td>
</tr>
</tbody>
</table>
<br><br>

<h2>The for ( ;  ;  ) loop</h2>
Petlja for( ; ; ) koristi se za ponavljanje dela programa više puta. Ako imate fiksni broj ponavljanja, preporučuje se upotreba petlje 'for'.

<h3>Primer</h3>

<xmp class="primer_ta">
var i;
for(i=1;i<=10;i++)
{
console.log("2 x "+ i +" =", 2*i);
}
</xmp>

<h3>Output</h3>

2 x 1 = 2<br>
2 x 2 = 4<br>
2 x 3 = 6<br>
2 x 4 = 8<br>
2 x 5 = 10<br>
2 x 6 = 12<br>
2 x 7 = 14<br>
2 x 8 = 16<br>
2 x 9 = 18<br>
2 x 10 = 20<br>

<div class="napomena">
U for petlji možemo kombinovati više uslova koristeći operator "," (zarez).
</div>
<br>
U sledećem primeru štampamo Febonačijeve brojeve koristeći samo jednu for petlju.
<br>

<xmp class="primer_ta">
    <!DOCTYPE html>
    <html>
    <body>
        <script>
            "use strict"
           for(let temp, a = 0, b = 1; b<40; temp = a, a = b, b = a + temp)   
           document.write(b+"<br>");  
        </script>

    </body>
</html>
</xmp>
<button class="button_copy">Vidi primer</button>


<h2>The for… in loop</h2>

Petlja for… in je slična 'for' petlji koja se ponavlja kroz svojstva objekta. Bolji je izbor kada radite sa objektima ili rečnicima gde redosled indeksa nije bitan.
U svakoj iteraciji, jedno svojstvo objekta dodeljuje se promenljivoj i petlja se nastavlja sve dok se sva svojstva objekta ne pokriju.


<xmp class="primer_ta">
<!DOCTYPE html>
<html>
<body>
	<script>
		function Mobile(model_no){   
			this.Model = model_no;  
			this.Color = 'White';  
			this.RAM = '4GB';  
		}  
	var Samsung = new Mobile("Galaxy");  
	for(var props in Samsung)  
	{  
	document.write(props+ " : " +Samsung[props]);  
	} 
	</script>
</body>
</html>
</xmp>
<button class="button_copy">Vidi primer</button>
<br>

<h2 style="color:brown" >The for…of loop</h2>
Za razliku od objektnih literala, ova petlja se koristi za iteracuju kroz nizove.
U svakoj iteraciji, jedan član niza dodeljuje se promenljivoj, a petlja se završava kada dođemo do poslednjeg elementa niza.

<xmp class="primer_ta">
<!DOCTYPE html>
<html>
<body>
<script>
let fruits = ['Apple', 'Banana', 'Mango', 'Orange'];
for(let value of fruits)
{
document.write(value+"<br>");
}
</script>
</body>
</html>
</xmp>
<button class="button_copy">Vidi primer</button>


<h2 style="color:brown">Indefine loops</a></h2>
Neodređena petlja ima beskonačno iteracija. Koristi se kada je broj ponavljanja naredbi prelazan ili nepoznat.

<h2  style="color:brown">While petlja</h2>

While petlja je kontrolni tok koji omogućava ponavljanje izvršenog koda na osnovu datog Booleovog uslova.
Sastoji se od blok koda i izraza.<br><br>
While petlja proverava izraz pre izvršavanja bloka; zato je ova kontrolna struktura inače poznata kao test petlja.<br>
<xmp class="primer_ta">
let count = 6, fact = 1;
while (count > 0)
{
fact = fact * count--;
}
console.log(fact);
</xmp>


<h2>Do…while petlja</h2>

To je izjava kontrolnog toka koja barem jednom izvršava blok koda, a onda zavisno od uslova izvršava blok više puta.<br><br>
Do…while petlja proverava uslov posle izvršenja bloka, zato je ova kontrolna struktura isto poznata kao post-test petlja.
Isto je moguće da se uslov proceni kao tačan, što će stvoriti beskonačnu petlju.(infinitive loop)<br>

<xmp class="primer_ta">
let count = 6, fact = 1;
do {
fact = fact * count--;
} while (count > 0);
</xmp>

Ključna razlika između gore dva navedena primera je u tome što se while petlja unosi samo ako je uslov koji je prenesen ocenjen tačnim. <br>
Ali do…while petlja izvršava izjavu jednom, dešava se zbog početne iteracije do...while petlje koja ne uzima u obzir kao Boolovim izrazom.<br>
Zatim za dalje iretacije, while će proveriti stanje i uzima kontrolu iz petlje.<br>
<div class="zadatak">
Zadatak: Napisati kod koji za dati niz celih brojeva nepoznate dužine ispisuje samo one brojeve koji su deljivi sa 3. Npr. [13,3,7,6,2,12] -> [3,6,12] 
</div>


