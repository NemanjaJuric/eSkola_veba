
<div class="half-panel-scrollable">

<h1><b>Topološko sortiranje</b></h1>
<br />
<br />
<h3><b>Uvod</b></h3>
<br />
Topološko sortiranje predstavlja neku vrstu uređenja čvorova grafa. Za neki niz čvorova grafa a1,a2,....,an gde je ai iz V za svako i iz {1,2,...,n} kažemo da je topološki sortiran ako ne postoji put od ai do aj gde je i>j. Topološko sortiranje možemo posmatrati kao da je za neki skup poslova koji međusobno zavise jedan od drugog potrebno naći redosled kojim ce se obaviti.<br />
Na primer potrebno je sagraditi kuću,poslovi su napraviti temelj, ozidati zidove, napraviti krov, jasno je da ne mozemo zidati zidove dok se ne napravi temelj, isto tako i za krov i zidove, jos se vidi da nije moguće postaviti krov ukoliko nemamo ni temelj, u grafu ćemo zavisnost poslova predstavljati granama, tj grana od sagraditi temelj ka sagraditi zidove će označavati da je potrebno prvo zavrsiti temelj da bi se zidovi počeli odnosno da zidanje zidova zavisi od temelja. Primetimo da postoji i zavisnost koja ne mora biti direktna tj ne oznacava samo jedna grana zavisnost već zavisnost možemo videti i na osnovu postojanja puta od čvora u do čvora v, takvu zavisnost vidimo na primeru da krov preko zidova zavisi i od temelja(postoji i direktna grana pa primer nije najsrećniji jer krov zavisi i direktno i tranzitivno od temelja). Ukoliko posao napraviti temelj označimo kao posao br 2, ozidati zidove sa 0, a krov sa 1, sledeći graf bi predstavljao datu situaciju:
<br /><br /><br />


<img style="width:230px; max-width:70%;" src="courses/grafovi/3_topolosko/topolosko1.png" class="img-fluid img-sm">

<br>
Niz 2,0,1 zadovoljava uslov topoloskog sortiranja, tj iz čvora 0 granama ne možemo doći do čvora 2, takođe iz čvora 1 ne možemo ni do 0 ni do 2. Ovoj topološko sortiranje nam kaže ono sta smo već znali, da ukoliko gradimo kuću moramo početi od temelja preko zidova pa tek na kraju možemo praviti krov, iako je ovaj primer bio očigledan topološko sortiranje daje odgovor i u mnogo zahtevnijim primerima.
<br><br>
Topološko sortiranje nije moguće u neusmerenim grafovima jer kako god da rasporedimo čvorove, uzmemo jednu granu (a,b) neki od čvorova a i b mora biti ispred onog drugog, a samim tim i ne zadovoljavamo uslove topološkog sortiranja jer postoji put i od a do b i od b do a. Iako ima smisla samo posmatrati topolosko sortiranje za usmerene grafove nemaju svi usmereni grafovi topološko sortiranje. Na primer za sledeći graf ni jedan raspored čvorova ne predstavlja topološki sortirane čvorove:
<br><br>
<img style="width:230px; max-width:70%;" src="courses/grafovi/3_topolosko/topolosko2.png" class="img-fluid img-sm">
<br>
Lako se vidi da je dovoljan uslov da neki usmereni graf ima topološki redosled čvorova je da u njemu nema ciklusa. Postoje algoritmi za izračunavanje topološkog redosleda čvorova, a jedan od njih je Kanov algoritam.
<br><br>

<h3><b>Kanov algoritam</b></h3>


<br><br>
Kanov algoritam predstavlja jedan od algoritama za topološko sortiranje i zasniva se na principu matematičke indukcije tj da izdvojimo jedan čvor, sortiramo ostatak, i dodamo taj jedan. Postavlja se pitanje kako izabrati čvor koji treba izdvojiti. Najlogičniji izbor je da se izabere čvor koji ne zavisi ni od jednog drugog čvora, jer njega znamo da možemo numerisati kao prvi element, zatim izbacimo njega i numerišemo ostatak grafa brojevima 2 do n. Da li uvek postoji čvor tako da ne zavisi ni od jednog, odgovor je pozitivan ukoliko u usmerenom grafu ne postoji ciklus.
 <br>
Kako odrediti čvor koji ne zavisi ni od jednog drugog? 
<br>
Pošto smo zavisnost čvora a od čvora b predstavljali granom (b,a) broj čvorova od kojih zavisi čvor a je stepen čvora(podsećanje: stepen čvora predstavlja broj ulaznih grana nekog čvora).

<br><br>

Pošto se prethodni postupak ponavlja iznova i iznova dok ne rasporedimo sve čvorove, algoritam se sastoji iz sledećih delova:

<ul>
  <li>računaćemo stepene svih čvorova(stepene čvorova ćemo smeštati u jedan niz u kom će na indeksu i biti stepen čvora sa rednim brojem i),</li>
  <li> sve čvorove stepena nula smestićemo u stek(ili red svejedno)</li>
  <li> u petlji ćemo se vrteti sve dok ne ispraznimo stek, dok ćemo u svakoj iteraciji petlje čvor koji je na vrhu steka ubaciti u niz koji će na kraju algoritma predstavljati topološki poredak, smanjićemo stepene svih suseda čvora koji je bio na vrhu steka, ukoliko je neki od tih stepena postao nula ubacimo u stek i nastavimo</li>
  
</ul> 


<br>
Implementacija Kanovog algoritma: 
<xmp class="primer_ta">
void Kanov_algoritam(vector<vector<int>> &lista_povezanodsti){
    int n=lista_povezanodsti.size();    //broj cvorova u grafu
    vector<int> stepen(n);              //stepen svakog cvora 
    vector<int> topoloski_sortirani;    //niz u kome smestamo cvorove topoloski sortirano
    stack<int> stek;                    //stek potreban za algoritam, isto bi bilo i sa redom
    
    //racunamo stepene cvorova
    for(int i=0;i<n;i++){
        for (int a:lista_povezanodsti[i]){
            stepen[a]++;
        }
    }
    
    //ubacujemo u stek sve cvorove ciji je stepen nula
    for(int i=0;i<n;i++){
        if(stepen[i]==0) stek.push(i);
    }


    int vrhsteka;
    while(!stek.empty()){  //u petlji smo sve dok postoji neki čvor u steku
        vrhsteka=stek.top();
        topoloski_sortirani.push_back(vrhsteka); //vrh steka ubacujemo u topološki redosled
        stek.pop();
        for(int i:lista_povezanodsti[vrhsteka]){    
            //proveravamo jel mozda neki od suseda moze da se ubaci u stek
            if(--stepen[i]==0)
                stek.push(i);
        }
    }

    //stampamo topoloski sortirane cvorove

    for(int i=0;i<n-1;i++){
        cout<<topoloski_sortirani[i]<<" -> ";
    }
    cout<<topoloski_sortirani[n-1]<<'\n';


}

</xmp>

<br>


<br>

<h3>Topološko sortiranje pomoću DFS </h3>
<br>


Algoritam za topološko sortiranje zasnovan na DFS obilasku grafa se zasniva na činjenici da na kraju rekurzivnog poziva algoritma DFS obiđu se svi čvorovi koji i direktno i tranzitivno zavise od čvora koji vraća rekurzivni poziv. Samim tim znamo da on dolazi ispred svih tih čvorova u topološkom poretku, što dalje znači da ukoliko imamo redosled kojim su se završavali rekurzivni pozivi za sve čvorove potrebno je samo okrenuti taj redosled i dobijamo topološki redosled.


<br><br>
Implementacija topološkog sortiranja pomoću DFS-a: 
<xmp class="primer_ta">
void dfs(int u,vector<int> &DFSraspored) { 
    posecen[u]=true;
    for(int i:lista_povezanosti[u]){
        if(!posecen[i])
        dfs(i,DFSraspored);         //ovo nam osigurava da se svi cvorovi koji zavise od u smeste u DFSraspored pre cvora u
    }
    DFSraspored.push_back(u);       // cvor u se dodaje u niz tek kada se svi ostali koji zavise od njega dodaju
}

void topoloskoDFS(){
    vector<int> DFSraspored; //vektor za redosled zavrsetka rekurzivnog poziva

    //osiguravamo se da smo posetili sve cvorove DFS obilaskom
    for(int i=0;i<lista_povezanosti.size();i++){
        if(!posecen[i])
            dfs(i,DFSraspored);
    }

    //Jos samo da okrenemo vektor DFSraspored
    int n=DFSraspored.size()-1;
    for(int i=0;i<n;i++){
        cout<<DFSraspored[n-i]<<" -> ";
    }
    cout<<DFSraspored[0]<<endl;

}

</xmp>



Primer: Brojevi zapisani pored čvorova predstavljaju redosled kojim se završio rekurzivni poziv DFS obilaska grafa, pretpostavljajući da je lista povezanosti {{1},{6},{0,5},{0,2,5},{},{6},{4}}
<br>
<img style="width:530px; max-width:90%;" src="courses/grafovi/3_topolosko/topoloskoDFS.png" class="img-fluid img-sm">

<br />
Dobijemo topološki redosled ukoliko sortiramo čvorove opadajući po njihovom rednom broju kako su zavrsili rekurzivni poziv, tako dobijemo niz 3,2,5,0,1,6,4 što predstavlja topološki raspored. 



<h3>Prateći video materijali: </h3>
<br />
<video style="width:600px; max-width:98%;" controls>
      <source src="courses/grafovi/3_topolosko/topolosko.mp4" type="video/mp4" />
      Vaš pregledač ne podržava ovaj video format.
</video>
<br />
<br />
<h3>C++ kod implementacije: </h3>
Kod implementacije Kanovog algoritma možete preuzeti 
<a href="courses/grafovi/3_topolosko/kanovalg.cpp" download="courses/grafovi/3_topolosko/kanovalg.cpp">ovde
</a> ili ga možete probati 
<a target="_blank" rel="noopener noreferrer" href="https://repl.it/@eskolaveba/Kanovcpp" > ovde
</a>.
<br />
Kod implementacije algoritma zasnovanog na algoritmu DFS možete preuzeti
<a href="courses/grafovi/3_topolosko/topoloskoDFS.cpp" download="courses/grafovi/3_topolosko/topoloskoDFS.cpp">ovde
</a> ili ga možete probati <a target="_blank" rel="noopener noreferrer" href="https://repl.it/@eskolaveba/TopoloskoDFScpp" >ovde</a>
.
<br />
<br />
<br />
 </div>
 <div class="half-panel">
<iframe height="100%" width="100%" src="https://repl.it/@eskolaveba/Topoloskosve?lite=true" scrolling="no" frameborder="no" allowtransparency="true" allowfullscreen="true" sandbox="allow-forms allow-pointer-lock allow-popups allow-same-origin allow-scripts allow-modals"></iframe>
 </div>
